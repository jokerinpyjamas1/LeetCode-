### Day1刷题日志

#Finish reading 数组理论基础
过去不注重理论知识，对于数组概念比较模糊。
重读之后对于数组有了全新的认知。


###
704. 二分查找
通过不断二分index， 寻找target
易错： 1.while循环 break条件 < or <=
      2. if list[i] > target:
            right = middle or middle -1?
左闭右闭[a,b]  incluede a, b
左闭右开[a,b)  include a but not b

左闭右闭[a,b] 情况
区间是不变量，开始是左闭右闭， all codes needs to be [a,b]

Needs to determine if [a,b], allows a = b, then in while a <= b works 
                   if [a,b), not allow a = b, then in while a < b works 
pseudocode：
left = 0
right = numsize - 1
while left <= right:
      middle = (left + right) /2 注意是否越界
      if nums[middle] > target,  当target在middle的左边
(右边界为闭区间，middle已经必然大于target，区间已经不续约不包含middle，所以middle - 1) 
            '''update right'''
            right = middle - 1 
      else if nums[middle] < target: 当target在middle的右边
(左边界为闭区间，middle已经必然小于target，区间已经不需要包含middle，所以middle + 1) 
            left = middle + 1 
      else
            return middle 
都没找到，则
return -1

左闭右开[a,b） 情况， [a,b), not allow a = b
pseudocode：
left = 0
right = numsize
while left < right: 只有left < right 才有意义
      middle = (left + right) /2 注意是否越界
      if nums[middle] > target,  当target在middle的左边
      （由于区间左闭右开，更新左区间的右边界，搜索区间本身不包含right，所以right = middle即可）
            '''update right'''
            right = middle  
      else if nums[middle] < target: 当target在middle的右边
(左边界为闭区间，middle已经必然小于target，区间已经不需要包含middle，所以middle + 1) 
            left = middle + 1 
      else
            return middle 
都没找到，则
return -1
27. 移除元素  
